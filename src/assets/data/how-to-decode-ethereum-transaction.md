#### Table of Contents

1. <a href="#what-is-Ethereum-transaction-log-data">What is Ethereum transaction log data?</a>
2. <a href="#how-to-decode-it-using-ethers-libraries">How to decode it using ethers libraries?</a>
3. <a href="#conclusion">Conclusion</a>

<Alert type="primary">
⚠️  Although `ethers` is now version 6, I still use version 5 in this tutorial.
</Alert>


## 1. What is Ethereum transaction log data
- Ethereum transaction log data is a special type of data that is generated by smart contracts when they emit events.
- Events are custom messages that smart contracts can emit to notify external parties about something that happened on the blockchain. 

<Alert type="info">
For example, a token contract can emit a Transfer event when someone transfers tokens to another address. 
</Alert>

- Events are stored in transaction logs, which are part of the transaction receipts. 
- Transaction logs contain information such as the address of the smart contract that emitted the event, the topics of the event, and the data of the event. 
- The topics are used to identify the type and parameters of the event, and the data contains additional information about the event. 

<Alert type="info">
For example, a Transfer event may have three topics: the hash of the event name (Transfer), the address of the sender, and the address of the receiver. The data may contain the amount of tokens transferred.
</Alert>


## 2. How to decode it using `ethers` library

In this part, I'm going to show you 2 common way to decode the Ethereum transaction log data.

<Alert type="warning">
Reminder: You must have the ABI of the contract that you've made a transaction on it.
</Alert>


**However, watch till the end, the a particular bonus for you!**

#### 2.1 Using `ethers.utils.Interface`

- First, let declare the ABI of the contract, which I've mentioned before, and put it into the `Interface`

<Code language="javascript">
// you can get the ABI of smart contract at the Code tab
const abi = [ ... ];
const iface = new ethers.utils.Interface(abi)
</Code>

- Now, let's try parsing the logs. 
*Because transaction may contains many logs, so we need to try parsing to make sure to get the right what we want.*

<Code language="javascript">
// get transaction receipt
provider.getTransactionReceipt("'transaction receipt'")
  .then((receipt) => {
    receipt.logs.map((log) => {
      try {
        // parse lop
        console.log(iface.parseLog(log));
      } catch (error) {
        
      }
    });
  })
</Code>

- Full code: Let's decode [this transaction](https://etherscan.io/tx/0x04e5310388f21a05063f2d8453e5336c89ca53c332d2275f48adc35e2cc09cbd) event logs

<Code language="javascript">
const { ethers } = require("ethers");
const provider = ethers.providers.getDefaultProvider(1); // Ethereum chain id is 1
// you can get the ABI of smart contract at the Code tab
const abi = [{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newCounter","type":"uint256"},{"indexed":true,"internalType":"address","name":"offerer","type":"address"}],"name":"CounterIncremented","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"orderHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"offerer","type":"address"},{"indexed":true,"internalType":"address","name":"zone","type":"address"}],"name":"OrderCancelled","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"orderHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"offerer","type":"address"},{"indexed":true,"internalType":"address","name":"zone","type":"address"},{"indexed":false,"internalType":"address","name":"recipient","type":"address"},{"components":[{"internalType":"enum ItemType","name":"itemType","type":"uint8"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"identifier","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"}],"indexed":false,"internalType":"struct SpentItem[]","name":"offer","type":"tuple[]"},{"components":[{"internalType":"enum ItemType","name":"itemType","type":"uint8"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"identifier","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"address payable","name":"recipient","type":"address"}],"indexed":false,"internalType":"struct ReceivedItem[]","name":"consideration","type":"tuple[]"}],"name":"OrderFulfilled","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"orderHash","type":"bytes32"},{"components":[{"internalType":"address","name":"offerer","type":"address"},{"internalType":"address","name":"zone","type":"address"},{"components":[{"internalType":"enum ItemType","name":"itemType","type":"uint8"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"identifierOrCriteria","type":"uint256"},{"internalType":"uint256","name":"startAmount","type":"uint256"},{"internalType":"uint256","name":"endAmount","type":"uint256"}],"internalType":"struct OfferItem[]","name":"offer","type":"tuple[]"},{"components":[{"internalType":"enum ItemType","name":"itemType","type":"uint8"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"identifierOrCriteria","type":"uint256"},{"internalType":"uint256","name":"startAmount","type":"uint256"},{"internalType":"uint256","name":"endAmount","type":"uint256"},{"internalType":"address payable","name":"recipient","type":"address"}],"internalType":"struct ConsiderationItem[]","name":"consideration","type":"tuple[]"},{"internalType":"enum OrderType","name":"orderType","type":"uint8"},{"internalType":"uint256","name":"startTime","type":"uint256"},{"internalType":"uint256","name":"endTime","type":"uint256"},{"internalType":"bytes32","name":"zoneHash","type":"bytes32"},{"internalType":"uint256","name":"salt","type":"uint256"},{"internalType":"bytes32","name":"conduitKey","type":"bytes32"},{"internalType":"uint256","name":"totalOriginalConsiderationItems","type":"uint256"}],"indexed":false,"internalType":"struct OrderParameters","name":"orderParameters","type":"tuple"}],"name":"OrderValidated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32[]","name":"orderHashes","type":"bytes32[]"}],"name":"OrdersMatched","type":"event"}]
// declare the Interface
const iface = new ethers.utils.Interface(abi);
// get transaction receipt
provider.getTransactionReceipt("0x04e5310388f21a05063f2d8453e5336c89ca53c332d2275f48adc35e2cc09cbd")
  .then((receipt) => {
    receipt.logs.map((log) => {
      try {
        // parse lop
        console.log(iface.parseLog(log));
      } catch (error) {
        console.log('skip');
      }
    });
  });
</Code>

- Let's run code and see the result

<Code language="shell">
$ node parseLog.js
skip
LogDescription {
  eventFragment: {
    name: 'OrderFulfilled',
    anonymous: false,
    inputs: [
      [ParamType],
      [ParamType],
      [ParamType],
      [ParamType],
      [Object],
      [Object]
    ],
    type: 'event',
    _isFragment: true,
    constructor: [Function: EventFragment] {
      from: [Function (anonymous)],
      fromObject: [Function (anonymous)],
      fromString: [Function (anonymous)],
      isEventFragment: [Function (anonymous)]
    },
    format: [Function (anonymous)]
  },
  name: 'OrderFulfilled',
  signature: 'OrderFulfilled(bytes32,address,address,address,(uint8,address,uint256,uint256)[],(uint8,address,uint256,uint256,address)[])',
  topic: '0x9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31',
  args: [
    '0x08d8c02bc110a61a46c96c19877210ecb4287681a8c77819bf0d98335141580f',
    '0x902536FaE48B23669dF5fBe17FE4A92f9bD3AA2b',
    '0x004C00500000aD104D7DBd00e3ae0A5C00560C00',
    '0x6b0B071963681A669800A3fdAce4a550C84117fe',
    [ [Array] ],
    [ [Array], [Array], [Array] ],
    orderHash: '0x08d8c02bc110a61a46c96c19877210ecb4287681a8c77819bf0d98335141580f',
    offerer: '0x902536FaE48B23669dF5fBe17FE4A92f9bD3AA2b',
    zone: '0x004C00500000aD104D7DBd00e3ae0A5C00560C00',
    recipient: '0x6b0B071963681A669800A3fdAce4a550C84117fe',
    offer: [ [Array] ],
    consideration: [ [Array], [Array], [Array] ]
  ]
}
</Code>


## 3. Conclusion

In this blog, I’ve walked you through the process of decoding Ethereum transaction log data using the ethers library1. I’ve shared two effective methods to parse this data: one using the ethers.utils.Interface class and the other using the ethers.utils.defaultAbiCoder function. I’ve also provided some practical examples of code and their corresponding outputs for each method. Decoding Ethereum transaction log data is a powerful tool for gaining insights into blockchain activities and interacting with smart contracts. I hope you found this guide helpful and informative. Happy coding!

Don't forget to follow for more!